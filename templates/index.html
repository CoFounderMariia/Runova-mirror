<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="theme-color" content="#000000">
  <link rel="manifest" href="/manifest.json">
  <title>RUNOVA Mirror</title>

<style>

  /* ---- VARIABLES ---- */
  :root {
    --frame: #f4f3f2;
    --screen-bg-top: #d5d9de;
    --screen-bg-bottom: #a5aab4;
  }

  /* ---- RESET ---- */
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #e7e3e1;
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
  }

  /* ---- MIRROR FRAME ---- */
  #cam {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 1;            /* –ö–õ–Æ–ß–ï–í–û */
    pointer-events: none;
    transform: scaleX(-1);
    z-index: 0;
  }

  /* FaceMesh Canvas overlay */
  .face-mesh-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
  }

  /* ---- PERFECT STAND (—Ä–µ–Ω–¥–µ—Ä —Ç–æ—á–Ω—ã–π) ---- */

  /* –®–ï–Ø - –∫–≤–∞–¥—Ä–∞—Ç–Ω–∞—è —Ñ–æ—Ä–º–∞ */
  /* STATUS TEXT */
  #statusText {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    padding: 6px 14px;
    background: rgba(0,0,0,0.6);
    color: #fff;
    font-size: 13px;
    border-radius: 999px;
  }

</style>

<!-- MediaPipe FaceMesh -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script src="/static/mobile_ui/quality-gate.js"></script>
<script src="/static/mobile_ui/app.js"></script>
<script src="/static/mobile_ui/product-manager.js"></script>

</head>
<body>

<script>
  console.error("üö® REAL TEMPLATE LOADED:", location.pathname);
</script>

  <div class="mirror-frame">
    <div class="camera-dot"></div>

    <div class="video-screen">
      <video id="cameraVideo" autoplay playsinline muted></video>
      <canvas id="faceMeshCanvas" class="face-mesh-canvas" style="display:none;"></canvas>
    </div>

    <div class="stand-neck"></div>
    <div class="stand-base"></div>

    <button id="restartButton" class="restart-scan-button" title="Restart">
      <svg class="restart-scan-icon" viewBox="0 0 24 24">
        <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
        <path d="M21 3v5h-5"/>
        <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
        <path d="M3 21v-5h5"/>
      </svg>
    </button>

    <button id="micButton" class="mic-button" title="Voice recording (tap to toggle)" onclick="console.log('üé§ Mic button clicked!');">
      <svg class="mic-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 1C10.34 1 9 2.34 9 4V12C9 13.66 10.34 15 12 15C13.66 15 15 13.66 15 12V4C15 2.34 13.66 1 12 1Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="M19 10V12C19 15.87 15.87 19 12 19C8.13 19 5 15.87 5 12V10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        <line x1="12" y1="19" x2="12" y2="23" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        <line x1="8" y1="23" x2="16" y2="23" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
      </svg>
    </button>

    <button id="analyzeSkinBtn" class="analyze-button">Analyze skin</button>
    <button id="scanSunscreenBtn" class="scan-sunscreen-button">Scan sunscreen</button>

    <div id="recommendationsSection" class="recommendations-section"></div>

    <div id="skinResultsPanel">
      <div class="skin-results-header">
        <div class="skin-results-title">Skin analysis</div>
        <button id="skinResultsClose" class="skin-results-close">&times;</button>
      </div>
      <div class="skin-results-grid" id="skinResultsGrid"></div>
    </div>

  </div>

<script>
  // MediaPipe FaceMesh initialization
  let faceMesh = null;
  let camera = null;
  const canvas = document.getElementById("faceMeshCanvas");
  const canvasCtx = canvas.getContext("2d");

  // Face zones definition (correct indices for MVP)
  const ZONES = {
    forehead: [10, 338, 297, 332, 284, 251, 389, 356],
    nose: [1, 2, 98, 327],
    left_cheek: [50, 187, 207, 216, 212],
    right_cheek: [280, 425, 411, 371, 352]
  };

  const ZONE_COLORS = {
    forehead: 'rgba(255, 200, 0, 0.3)',
    nose: 'rgba(0, 255, 200, 0.3)',
    left_cheek: 'rgba(255, 0, 200, 0.3)',
    right_cheek: 'rgba(0, 200, 255, 0.3)',
  };

  function getZoneCoordinates(landmarks, zonePoints) {
    if (!landmarks || zonePoints.length === 0) return null;

    const points = zonePoints
      .filter(index => landmarks[index] !== undefined)
      .map(index => {
        const lm = landmarks[index];
        return {
          x: canvas.width - lm.x * canvas.width,
          y: lm.y * canvas.height,
          z: lm.z || 0,
        };
      });

    return points.length >= 2 ? points : null;
  }

  function drawZone(ctx, points, color) {
    if (!points || points.length < 2) return;

    ctx.beginPath();
    points.forEach((p, i) => {
      if (i === 0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    });
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.35;
    ctx.fill();
    ctx.globalAlpha = 1.0;
  }

  function computeMissingSunscreenZones(landmarks) {
    if (!landmarks) return null;

    const sunscreenAnalysis = analyzeSunscreen(landmarks);
    if (!sunscreenAnalysis) return null;

    const problematicZones = {};
    for (const [zoneName, zoneIndices] of Object.entries(ZONES)) {
      if (sunscreenAnalysis[zoneName]) {
        const status = sunscreenAnalysis[zoneName].status;
        if (status === "NO_SUNSCREEN" || status === "uneven") {
          problematicZones[zoneName] = { indices: zoneIndices, status };
        }
      }
    }
    return problematicZones;
  }

  function drawZones(currentLandmarks) {
    if (!currentLandmarks || !sunscreenZones) return;

    for (const [zoneName, zoneData] of Object.entries(sunscreenZones)) {
      const points = getZoneCoordinates(currentLandmarks, zoneData.indices);
      if (points && points.length >= 2) {
        const zoneColor = getZoneStatusColor(zoneData.status);
        drawZone(canvasCtx, points, zoneColor);
      }
    }
  }

  function analyzeSunscreen(landmarks) {
    if (!landmarks) return null;

    const camEl = document.getElementById("cameraVideo");
    const originalTransform = camEl.style.transform;
    camEl.style.transform = "none";

    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
    const tempCtx = tempCanvas.getContext("2d");
    tempCtx.drawImage(camEl, 0, 0, tempCanvas.width, tempCanvas.height);
    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

    camEl.style.transform = originalTransform || "scaleX(-1)";

    const sunscreenAnalysis = {};
    for (const [zoneName, zoneIndices] of Object.entries(ZONES)) {
      const points = getZoneCoordinates(landmarks, zoneIndices);
      if (points) {
        const variance = analyzeZone(imageData, points);
        const status = getSunscreenStatus(variance);
        sunscreenAnalysis[zoneName] = { variance, status };
      }
    }
    return sunscreenAnalysis;
  }

  function analyzeZone(imageData, points) {
    if (!points || points.length === 0) return null;

    let variance = 0;
    let mean = 0;
    let validPoints = 0;

    points.forEach(p => {
      const x = Math.floor(p.x);
      const y = Math.floor(p.y);
      if (x >= 0 && x < imageData.width && y >= 0 && y < imageData.height) {
        const i = (y * imageData.width + x) * 4;
        const brightness = (imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2]) / 3;
        mean += brightness;
        validPoints++;
      }
    });

    if (validPoints === 0) return null;
    mean /= validPoints;

    points.forEach(p => {
      const x = Math.floor(p.x);
      const y = Math.floor(p.y);
      if (x >= 0 && x < imageData.width && y >= 0 && y < imageData.height) {
        const i = (y * imageData.width + x) * 4;
        const brightness = (imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2]) / 3;
        variance += Math.pow(brightness - mean, 2);
      }
    });

    variance /= validPoints;
    return variance;
  }

  function getSunscreenStatus(variance) {
    if (variance === null || variance === undefined) return null;
    if (variance <= 120) return "OK";
    if (variance <= 200) return "uneven";
    return "NO_SUNSCREEN";
  }

  function getZoneStatusColor(status) {
    switch(status) {
      case "OK": return "rgba(100, 255, 100, 1)";
      case "uneven": return "rgba(255, 255, 100, 1)";
      case "NO_SUNSCREEN": return "rgba(255, 100, 100, 1)";
      default: return "rgba(255, 255, 255, 1)";
    }
  }

  let mode = "idle";
  let lockedLandmarks = null;
  let sunscreenZones = null;

  function onResults(results) {
    if (mode === "idle") return;

    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

    if (mode === "scanning" && results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
      lockedLandmarks = results.multiFaceLandmarks[0];
      sunscreenZones = computeMissingSunscreenZones(lockedLandmarks);
      mode = "locked";
    }

    if (mode === "locked" && results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
      const currentLandmarks = results.multiFaceLandmarks[0];
      drawZones(currentLandmarks);
    }

    canvasCtx.restore();
  }

  let cameraStream = null;

  async function startCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user" },
        audio: false
      });

      cameraStream = stream;

      const camEl = document.getElementById("cameraVideo");
      camEl.srcObject = stream;
      camEl.muted = true;
      await camEl.play();

      faceMesh = new FaceMesh({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`,
      });

      faceMesh.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      faceMesh.onResults(onResults);

      camEl.onloadedmetadata = () => {
        canvas.width = camEl.videoWidth;
        canvas.height = camEl.videoHeight;
      };

      camera = new Camera(camEl, {
        onFrame: async () => {
          await faceMesh.send({ image: camEl });
        },
        width: 640,
        height: 480,
      });
      camera.start();

    } catch (err) {
      console.error("Camera error:", err);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    startCamera();
  });
</script>

<script>
  (function hardRemoveCameraReady() {
    const BAD_IDS = new Set(["statusText", "cameraStatus"]);
    const BAD_CLASSES = new Set(["camera-status", "camera-ready"]);
    const BAD_TEXTS = new Set(["camera ready", "camera error", "cameraready", "cameraerror"]);

    function kill(el) {
      if (!el) return;
      try { el.remove(); } catch {}
    }

    function scan(root) {
      if (!root || !root.querySelectorAll) return;

      root.querySelectorAll("*").forEach((el) => {
        const id = (el.id || "").trim();
        if (BAD_IDS.has(id)) return kill(el);

        const classList = Array.from(el.classList || []);
        if (classList.some(c => BAD_CLASSES.has(c))) return kill(el);

        const t = ((el.textContent || "").trim().toLowerCase());
        if (t == "camera ready" || t == "cameraready" || t == "camera error" || t == "cameraerror") return kill(el);
      });
    }

    scan(document);

    const obs = new MutationObserver(() => scan(document));
    obs.observe(document.documentElement, { childList: true, subtree: true, characterData: true });
  })();
</script>

</body>
</html>
